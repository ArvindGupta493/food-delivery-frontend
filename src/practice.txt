FUNCTION Currying:
"When there is a function that takes multiple arguments we can transform its functionality using multiple functions that takes single argument this is called currying.

currying makes code more readable, the functions become reusable.

// function greet(greetText,name){
//     return `${greetText} ${name}`
// }

// console.log(greet("Hello","Sir"))

// const greet = (greetText,name)=>
// `${greetText} ${name}`
// console.log(greet("Hello","Sir"))

// function greet1(greetMessage){
//     return function (name){
//         return `${greetMessage} ${name}`
//     }
// }

// const fun1= greet1("Hello")
// const fun2=greet1("Hola")
// console.log(fun2("sir"))











Flat array:

we can make one array that will  extract element from any nested array inside it and place them it in as normal array elements upto a specified depth. by default depth is 1.

it gives shallow copy.

const arr= [1,2,['a','b','c'],4,5,['x',['y','z']]]
const flatnned= arr.flat(Infinity)
console.log(flatnned)// [1,2,a,b,c,4,5,x,y,z]

const arr= [1,2,['a','b','c'],4,5,['x',['y','z']]]
const flatnned= arr.flat(Infinity)
console.log(flatnned)// [1,2,a,b,c,4,5,x,y,z]


const greet = greetMessage=>name=>`${greetMessage} ${name}`
console.log(greet("Hello")("Sir"))












Shallow copy and deep copy

Shallow Copy:
A shallow copy creates a new object or array, but it only copies the references of nested objects/arrays instead of duplicating them. Changes to the nested structures in the copied object affect the original.

Deep Copy:
A deep copy creates a completely independent copy of an object or array, duplicating all nested objects/arrays as well. Changes in the copied object do not affect the original.

const arr=[1,2,3,['a','b','c'],{name:"prajjwal",age:24,sex:"Male"}]
// const arr2= [...arr]

// console.log("arr: ",arr)
// console.log("arr2: ",arr2)

// arr[0]=10;
// console.log(arr[0])
// // console.log(arr2[0])

// arr2[3][0]='x';
// console.log(arr[3][0])
// console.log(arr2[3][0])
//the change in non-primitive data type in anyone will chnage the original array because it is shallow copy and both of them points non-primitives at same reference.

//if we do not want this we can then create deep copies

// const arr2= JSON.parse(JSON.stringify(arr))
const arr2= structuredClone(arr)

console.log("arr : ",arr)
console.log("arr2: ",arr2)

// arr2[0]=10

// console.log(arr[0])
// console.log(arr2[0])


arr[3][0]='x'
console.log(arr[3][0])
console.log(arr2[3][0])

//we created deep copy hence the reference is dead and a new array is created by copying old array.







Union and intersection in array

const arr1=[1,2,3,3,4]
const arr2=[3,4,4,5,6,7,8]

const union = new Set([...arr1,...arr2])
console.log(union)
//[1,2,3,4,5,6,7,8]

const intersection= new Set(arr1.filter((ele)=>{
    return arr2.includes(ele)
}))
console.log(intersection)
//[3,4]










Hoisting:

the behaviour of JavaScript that enables the variables and functions declaration such that they are moved to top of their scope:

that means the variables and functions(function declarations) can be used  before the actual declaration.

variables declared using var , let and const all are hoisted but let and const goes in temporal dead zone hence cant be used before declaration.

the function declaration is hoisted but function expressions are not.


the hoisting is possible because while executing the js code the js engine makes a global execution context that is divided into 2 parts code execution and memory creation. so while compilation only the memory creation is done and memory for variables and functions is created.

the memory created for variables has value undefined in it but memory created for function has function definition in it.

but if we have a variable that stores function in it then in memory creation it has undefined in it that is why function declaration has hoisting but function expressions do not.




Closure:




In JS when a function remembers its scope as well as its lexical scope then it is called that inner function is forming closure with the outer function.

ex:  function fun1(){
let a=10;


am i right?
return function (){
let b=12
return a+b;
}
}

const f= fun1()
console.log(f())

will give output as 22


this is because fun2 is forming closure with fun1 and it remembers and can access its variables and functions along with its parent variables and functions lexically hence we can say closure is formed here


function currying is an example of closure 















This keyword && new keyword && arrow function and normal function difference



// This keyword refers to the object that is executing current function.

const obj = {
        name:"Prajjwal",
        fun(){
            console.log("fun",this)
        },

        arrow:()=>{
            console.log("arrow",this)

        }
    }

    obj.fun()
  //this inside a method(a method which is created using function declaration) referes to the object in which the method that is being executed is present 


    obj.arrow()

    //this inside a method (a method which is created using arrow function refers to lexical this that means this of the parent of the object in which it is present ) because arrow functions do not have their own this keyword.
That is the main difference between normal functions and 

  

    function fun1(){
        console.log(this)
    }
fun1()


//if our function is not inside any object then this refers to global object that is window in case of browser and global in case of node js



console.log(this)
//top level this refers to global object window in case of browser and empty object {} in case of node js



//Constructor function
function Info (name){
    this.name=name
    console.log(this)

}

const I1= new Info("Prajjwal")

// when we use this inside a constructor function and then we use new then an empty object is created and this points to that empty object.












map filter reduce splice ,slice and forOf forIn forEach 

const arr =[10,20,30,40,50,60]

//map

const marr= arr.map((item,index)=>{
    return item+1
})

console.log("map",marr)


//filter

const farr= arr.filter((item,index)=>{
    return index>2
})

console.log("filter",farr)

//reduce

const sum = arr.reduce((acc,curr)=>{
    
    return acc+curr
    
},0)


console.log(sum)

//slice

const slarr=arr.slice(2,5)
console.log("slice",slarr)

//splice

const sparr= arr.splice(2,3,'a','b')
console.log("arr",arr)
console.log("sparr",sparr)







For of , for in and forEach



//it is used when we use values of iterables(array,strings)
const arr =[10,20,30,40,50,60]
console.log("for of")
for(let ele of arr ){
    console.log(ele)
}


//it is used when we use index or keys of array or object
console.log("for in")
for (let index in arr){
    console.log(index,arr[index])
}


//it is used when we use arrays and we use call back function in it which has two parameters first one is value of array second one is index just like map  
console.log("for each")
arr.forEach((item,index)=>{
    console.log(index,item)
})















Class in js

class Person{
    constructor(name,age)
    {
        this.name=name
        this.age=age
    }
    
    sayHello(){
        console.log(`${this.name} has age of ${this.age} years`)
    }
}

const p1= new Person("Neil",35)

console.log(p1)
p1.sayHello()










Prototype in js means is an object that is used to inherit properties of an object if it is not found in it. so if a key or property is not found in an object it looks it into its prototype then its parent prototype and so on until it found it or  reaches null.

this is called prototypical inheritance or prototype chaining.





Babel is a transpiler that makes our modern javascript code backward compatible.
like if we write modern js code like arrow functions and all then to make it understood by old code bases which do not support es6 babel is used.

so babel basically transpiles modern code into older code that can be understood by older browsers and it make it backward compatible.

























1.Project (random questions like  middlewares , nested routing and all) ->  Middleware processes requests before responses (e.g., auth, logging). Nested routing structures routes hierarchically for better organization, common in React Router. 

2. Function currying -> Transforms a multi-argument function into nested functions accepting one argument at a time. 

3. This keyword-> depends on function invoke like in global scope- window , object method - object, arrow -> inherits from the enclosing scope.

4. Remove duplicate element from array ->   use set:->    const unique = [...new Set(arr)];

5. Deep copy and  shallow copy -> Shallow copies reference nested objects; deep copies create independent copies .

6. Rest operator and spread Operator -> Rest combines elements (`...nums`); Spread expands arrays/objects (`[...arr]`).  

7. Aggregation pipeline -> 
The Aggregate pipeline is a way to perform complex data processing and analysis on MongoDB collections. It’s a sequence of stages, each representing a specific operation (e.g., filtering, grouping, sorting), which transforms input documents into output results. The pipeline is defined as an array of stages and executed using the aggregate() method.

8. Indexing -> Enhances query speed by creating searchable data structures.  (from 0 like [0,1,2,3,4])

9. Use the filter method and find sum of array elements 

10. UseEffect hook -> Handles side effects (e.g., API calls). Runs on mount, update, or unmount based on dependencies. 

11. Difference b/w react fragment and div ->      Fragment: Groups without extra DOM nodes. Div adds DOM nodes.  

12. Why we use key while doing mapping in react-> This key is used by React to identify & keep track of each element in the list

13. What is role of NPM in web development->  Manages JavaScript packages for installation, dependencies, and version control.  

14. Projection in mongodb -> projection refers to the process of selecting only the necessary data from a document, rather than retrieving the entire document.

15. what is babel and what is its role in react -> Converts modern JavaScript/JSX into browser-compatible code.  

16. flat in array

17.union and intersection in array

18.closure and hoisting-> Closures retain scope access. Hoisting moves declarations to the top.
 










 


 answer all these questions in 50 words
Here are concise 50-word answers to your questions:

---

**1. Middlewares & Nested Routing**  
Middleware processes requests before responses (e.g., auth, logging). Nested routing structures routes hierarchically for better organization, common in React Router.  

**2. Function Currying**  
Transforms a multi-argument function into nested functions accepting one argument at a time.  

**3. `this` Keyword**  
Refers to the execution context. In arrow functions, it inherits from the enclosing scope; in regular functions, it depends on how they’re called.  

**4. Remove Duplicates**  
Use `Set`:  
```javascript
const unique = [...new Set(arr)];
```

**5. Deep vs. Shallow Copy**  
Shallow copies reference nested objects; deep copies create independent copies (e.g., `JSON.parse(JSON.stringify(obj))`).  

**6. Rest & Spread Operators**  
Rest combines elements (`...nums`); Spread expands arrays/objects (`[...arr]`).  

**7. Aggregation Pipeline**  
Processes MongoDB data via stages like `$match` (filtering) and `$group` (grouping data).  

The Aggregate pipeline is a way to perform complex data processing and analysis on MongoDB collections. It’s a sequence of stages, each representing a specific operation (e.g., filtering, grouping, sorting), which transforms input documents into output results. The pipeline is defined as an array of stages and executed using the aggregate() method.

**8. Indexing**  
Enhances query speed by creating searchable data structures.  

**9. Filter & Sum Array**  
Filter:  
```javascript
arr.filter((x) => x > 2);
```  
Sum:  
```javascript
arr.reduce((a, b) => a + b, 0);
```  

**10. `useEffect` Hook**  
Handles side effects (e.g., API calls). Runs on mount, update, or unmount based on dependencies.  

**11. Fragment vs. Div**  
Fragment: Groups without extra DOM nodes. Div adds DOM nodes.  

**12. Keys in React**  
Identifies list elements for efficient rendering and reconciliation.  

**13. NPM Role**  
Manages JavaScript packages for installation, dependencies, and version control.  

**14. MongoDB Projection**  
Includes/excludes fields in query results:  
```javascript
db.collection.find({}, { name: 1 });
```  

**15. Babel in React**  
Converts modern JavaScript/JSX into browser-compatible code.  

**16. `flat` Method**  
Flattens nested arrays to specified depth:  
```javascript
[1, [2, [3]]].flat(2);
```  

**17. Union & Intersection**  
Union combines unique elements:  
```javascript
[...new Set([...arr1, ...arr2])];
```  
Intersection finds common ones:  
```javascript
arr1.filter((x) => arr2.includes(x));
```  

**18. Closure & Hoisting**  
Closures retain scope access. Hoisting moves declarations to the top.  

















 Here’s a brief explanation of each topic:

### 1. **Project Questions**
- **Middlewares**: Functions in frameworks like Express.js that execute between request and response cycles, used for logging, authentication, validation, etc.
- **Nested Routing**: Defining routes within other routes, common in frameworks like React Router to organize components hierarchically.

------------------------------------------------------------------------------------------------------------------
---

### 2. **Function Currying**
Transforming a function with multiple arguments into a sequence of functions, each accepting one argument.  
Example:  
```javascript
function multiply(a) {
  return (b) => a * b;
}
const double = multiply(2);
console.log(double(5)); // Output: 10
```

------------------------------------------------------------------------------------------------------------------

### 3. **`this` Keyword**
Represents the context of the function execution, varying depending on how the function is invoked:
- **Global Scope**: `this` refers to `window` (or `global` in Node.js).
- **Object Method**: `this` refers to the object.
- **Arrow Functions**: `this` is lexically inherited from the enclosing scope.

------------------------------------------------------------------------------------------------------------------


### 4. **Remove Duplicate Elements from an Array**
Using `Set`:  
```javascript
const arr = [1, 2, 2, 3];
const unique = [...new Set(arr)];
console.log(unique); // [1, 2, 3]
```

------------------------------------------------------------------------------------------------------------------


### 5. **Deep Copy and Shallow Copy**
- **Shallow Copy**: Only copies the first layer. Changes in nested objects affect the original.
  ```javascript
  const obj = { a: 1, b: { c: 2 } };
  const copy = { ...obj };
  ```
- **Deep Copy**: Creates an independent copy of all nested objects.  
  Example:  
  ```javascript
  const deepCopy = JSON.parse(JSON.stringify(obj));
  ```

------------------------------------------------------------------------------------------------------------------


### 6. **Rest Operator and Spread Operator**
- **Rest (`...`)**: Combines multiple elements into an array.  
  ```javascript
  function sum(...nums) {
    return nums.reduce((a, b) => a + b);
  }
  ```
- **Spread (`...`)**: Expands elements.  
  ```javascript
  const arr = [1, 2];
  console.log([...arr, 3]); // [1, 2, 3]
  ```

------------------------------------------------------------------------------------------------------------------


### 7. **Aggregation Pipeline in MongoDB**
A series of stages like `$match`, `$group`, `$project` for processing data.  
Example:  
```javascript
db.collection.aggregate([
  { $match: { status: "active" } },
  { $group: { _id: "$category", total: { $sum: 1 } } }
]);
```

------------------------------------------------------------------------------------------------------------------


### 8. **Indexing**
Improves query performance by creating a data structure for faster searches.  
Example in MongoDB:  
```javascript
db.collection.createIndex({ name: 1 });
```

------------------------------------------------------------------------------------------------------------------


### 9. **Filter and Sum Array Elements**
```javascript
const arr = [1, 2, 3, 4];
const even = arr.filter((num) => num % 2 === 0);
const sum = arr.reduce((acc, val) => acc + val, 0);
console.log(even, sum); // [2, 4], 10
```

------------------------------------------------------------------------------------------------------------------


### 10. **`useEffect` Hook**
Runs side effects in React components (e.g., fetching data).  
```javascript
useEffect(() => {
  console.log("Component mounted");
  return () => console.log("Cleanup");
}, []);
```

------------------------------------------------------------------------------------------------------------------


### 11. **React Fragment vs. Div**
- **Fragment**: Groups children without adding an extra DOM node.  
  ```jsx
  <React.Fragment>...</React.Fragment>
  ```
- **Div**: Adds a DOM element.

------------------------------------------------------------------------------------------------------------------


### 12. **Key in React**
Helps React identify and track DOM elements during re-renders for better performance.

------------------------------------------------------------------------------------------------------------------


### 13. **Role of NPM**
Manages JavaScript packages for installation, versioning, and dependency management.

------------------------------------------------------------------------------------------------------------------


### 14. **Projection in MongoDB**
Specifies fields to include/exclude in query results:  
```javascript
db.collection.find({}, { name: 1, _id: 0 });
```

------------------------------------------------------------------------------------------------------------------


### 15. **Babel in React**
Transpiles modern JavaScript (ES6+) and JSX into browser-compatible code.

------------------------------------------------------------------------------------------------------------------


### 16. **`flat` in Array**
Flattens nested arrays.  
```javascript
const nested = [1, [2, [3]]];
console.log(nested.flat(2)); // [1, 2, 3]
```

------------------------------------------------------------------------------------------------------------------


### 17. **Union and Intersection in Arrays**
- **Union**: Combine unique elements.  
  ```javascript
  const union = [...new Set([...arr1, ...arr2])];
  ```
- **Intersection**: Common elements.  
  ```javascript
  const intersection = arr1.filter((x) => arr2.includes(x));
  ```

------------------------------------------------------------------------------------------------------------------


### 18. **Closure and Hoisting**
- **Closure**: A function that retains access to its lexical scope even when executed outside it.
  ```javascript
  function outer() {
    let count = 0;
    return function inner() {
      count++;
      return count;
    };
  }
  const counter = outer();
  console.log(counter()); // 1
  ```
- **Hoisting**: Variables and function declarations are moved to the top during compilation.  
  ```javascript
  console.log(a); // undefined
  var a = 5;
  ```

--- 

Let me know if you need deeper insights into any of these!